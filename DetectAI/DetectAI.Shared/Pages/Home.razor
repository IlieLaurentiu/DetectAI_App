@page "/"
@using DetectAI.Shared.Models
@using MudBlazor
@using FluentValidation
@using DetectAI.Shared.Services.Theme
@inject IThemeService ThemeSvc
@inject ISnackbar Snackbar
@inject HttpClient Http
@inject NavigationManager Nav
@inject ForensicsState State

<style>
    .file-upload-input {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
        z-index: 10;
        opacity: 0;
    }
</style>
    
@if (hasUploadedFiles)
{
    <MudStack Class="mx-8 justify-content-center align-items-center">
        <MudText Typo="Typo.h3" Class="mt-8">Sending content to Analysis</MudText>
        <MudText Typo="Typo.h6" Class="d-flex align-items-center">Waiting API Response...</MudText>
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    </MudStack>
}
else
{
    <MudStack Class="mx-8 d-flex flex-column justify-content-center align-items-center">
        <MudText Typo="Typo.h3" Class="mt-8">AI Content Detector</MudText>
        <MudText Typo="Typo.h6" Class="d-flex align-items-center">
            Start AI content detection from:
            <MudChipSet T="string"
                        @bind-SelectedValue="_detectionMode"
                        @bind-SelectedValue:after="OnModeChanged"
                        SelectionMode="SelectionMode.SingleSelection"
                        CheckMark
                        Class="ml-4">
                <MudChip Text="Media" Value="@("Media")" Color="Color.Primary" Variant="@(_detectionMode == "Media" ? Variant.Outlined : Variant.Filled)">
                    <MudIcon Icon="@Icons.Material.Filled.VideoFile" Class="mr-1"/>Media
                </MudChip>
                <MudChip Text="Text" Value="@("Text")" Color="Color.Primary" Variant="@(_detectionMode == "Text" ? Variant.Outlined : Variant.Filled)">
                    <MudIcon Icon="@Icons.Material.Filled.TextFields" Class="mr-1" />Text
                </MudChip>

            </MudChipSet>
        </MudText>

        @if(_detectionMode == "Text")
        {
            <MudTextField T="string" 
                          @bind-Value="TextFieldString" 
                          Label="Paste Text Here To Begin Analysis"
                          Variant="Variant.Filled" 
                          Clearable="true" 
                          Immediate="true" 
                          Lines="10"
                          Style="width: 50dvw;"
                          Class="mt-3">
            </MudTextField>
        }
        else
        {
            <MudForm Model="@_model"
                     @bind-IsValid="_isValid"
                     @bind-IsTouched="_isTouched"
                     Validation="@_validationRules.ValidateValue">

                <MudItem xs="12">
                <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                               @key="AcceptStringChips"
                               Accept="@AcceptStringChips"
                               @ref="_fileUpload"
                               Files="@_model.Files"
                               FilesChanged="OnFilesChanged"
                               For="@(() => _model.Files)"
                               AppendMultipleFiles
                               Hidden="false"
                               InputClass="file-upload-input"
                               ErrorText="@string.Empty"
                               tabindex="-1"
                               @ondrop="@ClearDragClass"
                               @ondragenter="@SetDragClass"
                               @ondragleave="@ClearDragClass"
                               @ondragend="@ClearDragClass"
                               Style="width: 50dvw;">

                        <ActivatorContent>
                            <MudPaper Height="300px" Outlined="true" Class="@_dragClass">
                                <MudText Typo="Typo.h6">Drag & drop <br /> Your files here or browse to upload  </MudText>
                                <MudText Color="Color.Primary"><b>Only images, videos, audio or text files</b></MudText>
                                @foreach (var file in _model.Files?.Select(f => f.Name) ?? Enumerable.Empty<string>())
                                {
                                    <MudChip T="string" Color="Color.Dark" Text="@file" />
                                }
                            </MudPaper>
                        </ActivatorContent>
                    </MudFileUpload>
                    <MudToolBar Gutters="@false"
                                Class="relative d-flex justify-end gap-4">
                        <MudButton Color="Color.Primary"
                                   OnClick="@OpenFilePickerAsync"
                                   Variant="Variant.Filled">
                            <MudIcon Icon="@Icons.Material.Filled.UploadFile"></MudIcon>
                            Open file picker
                        </MudButton>
                        <MudButton Color="Color.Primary"
                                   Disabled="@(!_isValid || !_isTouched || _model.Files is null || !_model.Files.Any() || string.IsNullOrEmpty(_detectionMode))"
                                   OnClick="@Upload"
                                   Variant="Variant.Filled">
                            Upload
                        </MudButton>
                        <MudButton Color="Color.Error"
                                   Disabled="@(_model.Files is null || !_model.Files.Any())"
                                   OnClick="@ClearAsync"
                                   Variant="Variant.Filled">
                            Clear
                        </MudButton>
                    </MudToolBar>
                </MudItem>
            </MudForm>
        }

    </MudStack>
}


@code {
    #nullable enable
    public class Model
    {
        public IReadOnlyList<IBrowserFile>? Files { get; set; } = new List<IBrowserFile>();
    }

    private Model _model = new();
    private ModelFluentValidator _validationRules = new();
    private MudFileUpload<IReadOnlyList<IBrowserFile>>? _fileUpload;
    private bool _isValid;
    private bool _isTouched;
    private const string FileContent = "this is content";
    private const string DefaultDragClass = "relative rounded-lg border-2 border-dashed pa-4 mt-4 mud-width-full mud-height-full";
    private string _dragClass = DefaultDragClass;
    private List<string> _detectionMethodSelected = new();
    private string? _detectionMode = "Media";
    private bool hasUploadedFiles = false; // drives the "Analyzing Content" UI
    private bool isUploading = false;      // disables button and prevents double submits
    private bool _dark = false;
    private string TextFieldString { get; set; }

    private string AcceptStringChips
    {
        get
        {
            if (string.Equals(_detectionMode, "Media", StringComparison.OrdinalIgnoreCase))
            {
                // Media = Image ∪ Video ∪ Audio
                var keys = new[] { "Image", "Video", "Audio" };
                var parts = keys.Where(k => _acceptByMethod.ContainsKey(k))
                                .Select(k => _acceptByMethod[k])
                                .SelectMany(s => s.Split(',', StringSplitOptions.RemoveEmptyEntries))
                                .Select(s => s.Trim())
                                .Distinct(StringComparer.OrdinalIgnoreCase);
                return string.Join(',', parts);
            }

            if (!string.IsNullOrEmpty(_detectionMode) &&
                _acceptByMethod.TryGetValue(_detectionMode, out var accept))
                return accept;

            return string.Empty; // no filter
        }
    }

    private HashSet<string> AllowedExtensionsForCurrentMode()
    {
        IEnumerable<string> parts = Array.Empty<string>();

        if (string.Equals(_detectionMode, "Media", StringComparison.OrdinalIgnoreCase))
        {
            var keys = new[] { "Image", "Video", "Audio" };
            parts = keys.Where(k => _acceptByMethod.ContainsKey(k))
                        .SelectMany(k => _acceptByMethod[k].Split(',', StringSplitOptions.RemoveEmptyEntries));
        }
        else if (!string.IsNullOrEmpty(_detectionMode) && _acceptByMethod.TryGetValue(_detectionMode, out var accept))
        {
            parts = accept.Split(',', StringSplitOptions.RemoveEmptyEntries);
        }

        // Keep only explicit .ext tokens
        return parts.Select(p => p.Trim())
                    .Where(p => p.StartsWith('.'))
                    .Select(p => p.ToLowerInvariant())
                    .ToHashSet();
    }

    private void OnFilesChanged(IReadOnlyList<IBrowserFile>? files)
    {
        // Normalize null to empty
        files ??= Array.Empty<IBrowserFile>();

        var allowed = AllowedExtensionsForCurrentMode();

        // If we don’t have any explicit extensions (e.g., only MIME types),
        // just accept as-is (the Accept attribute will have done its best).
        if (allowed.Count == 0)
        {
            _model.Files = files;
            _isTouched = true;
            StateHasChanged();
            return;
        }

        var valid = files
            .Where(f => f is not null) // just in case
            .Where(f => allowed.Contains(Path.GetExtension(f.Name).ToLowerInvariant()))
            .ToList();

        // Tell user if anything got filtered out
        if (valid.Count != files.Count)
        {
            var removed = files.Except(valid).Select(f => f.Name);
            Snackbar.Add($"Removed unsupported files: {string.Join(", ", removed)}", MudBlazor.Severity.Warning);
        }

        _model.Files = valid;
        _isTouched = true;
        StateHasChanged();
    }

    protected override async Task OnInitializedAsync()
    {
        _dark = ThemeSvc.IsDarkMode;
        ThemeSvc.Changed += OnThemeChanged;

        try
        {
            var pong = await Http.GetStringAsync("/ping");
            if (!pong.Contains("pong"))
                Snackbar.Add("API ping did not return pong.", MudBlazor.Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"API not reachable: {ex.Message}", MudBlazor.Severity.Error);
        }
    }

    private void OnThemeChanged()
    {
        _dark = ThemeSvc.IsDarkMode;
        InvokeAsync(StateHasChanged);
    }

    private async Task Upload()
    {
        if (_model.Files is null || !_model.Files.Any()) return;

        var allowed = AllowedExtensionsForCurrentMode();

        if (allowed.Count > 0)
        {
            var bad = _model.Files.Where(f => !allowed.Contains(Path.GetExtension(f.Name).ToLowerInvariant()))
                                  .Select(f => f.Name).ToList();
            if (bad.Count > 0)
            {
                Snackbar.Add($"These files are not allowed: {string.Join(", ", bad)}", MudBlazor.Severity.Warning);
                return;
            }
        }

        var file = _model.Files.First();

        isUploading = true;
        hasUploadedFiles = true;     // show spinner
        StateHasChanged();

        try
        {
            Snackbar.Configuration.PositionClass = Defaults.Classes.Position.TopCenter;
            Snackbar.Add($"Uploading {_model.Files.Count} file(s) for {_detectionMode}...", MudBlazor.Severity.Info);
            var result = await SendToForensics(file);
            State.LastResult = result;
            Nav.NavigateTo("/AnalysisResults");   // will Navigate on success
                                           // If you navigate inside SendToForensics, the current page will unmount, so no need to reset state here.
        }
        catch (Exception ex)
        {
            // show the form again and inform the user
            hasUploadedFiles = false;
            Snackbar.Add($"Upload failed: {ex.Message}", MudBlazor.Severity.Error);
            StateHasChanged();
        }
        finally
        {
            isUploading = false;
        }
    }


    private void SetDragClass()
    => _dragClass = $"{DefaultDragClass} mud-border-primary";

    private void ClearDragClass()
    => _dragClass = DefaultDragClass;

    private Task OpenFilePickerAsync()
    => _fileUpload?.OpenFilePickerAsync() ?? Task.CompletedTask;

    private Task ClearAsync()
    => _fileUpload?.ClearAsync() ?? Task.CompletedTask;

    public class ModelFluentValidator : AbstractValidator<Model>
    {
        public ModelFluentValidator()
        {
            RuleFor(x => x.Files)
            .NotEmpty()
            .WithMessage("There must be at least 1 file.");
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<Model>.CreateWithOptions((Model)model, x => x.IncludeProperties(propertyName)));
            return result.IsValid ? Array.Empty<string>() : result.Errors.Select(e => e.ErrorMessage);
        };
    }

    private async Task<ForensicsResult?> SendToForensics(IBrowserFile file)
    {
        using var content = new MultipartFormDataContent();
        await using var stream = file.OpenReadStream(200 * 1024 * 1024);
        using var fileContent = new StreamContent(stream);
        content.Add(fileContent, "file", file.Name);

        var res = await Http.PostAsync("/forensics/analyze?verbose=true", content);
        res.EnsureSuccessStatusCode();

        var result = await res.Content.ReadFromJsonAsync<ForensicsResult>();
        return result;
    }

    private static readonly Dictionary<string, string> _acceptByMethod = new()
    {
        ["Image"] = "image/*,.jpg,.jpeg,.png,.webp,.bmp,.tiff",
        ["Video"] = "video/*,.mp4,.mov,.avi,.mkv,.webm",
        ["Audio"] = "audio/*,.mp3,.wav,.flac,.aac,.ogg",
        ["Text"] = "text/plain,.txt,.md" // expand if you’ll parse others
        // NOTE: Avoid .docx/.pdf unless you actually support them.
    };

    private string AcceptString
        => (_detectionMethodSelected?.FirstOrDefault() is { } mode
            && _acceptByMethod.TryGetValue(mode, out var accept))
            ? accept
            : string.Empty; // allow anything when not selected

    private async Task OnModeChanged()
    {
        // Reset model state first
        _model.Files = Array.Empty<IBrowserFile>();
        _isValid = _isTouched = false;
        hasUploadedFiles = false;

        // Clear the component (this can raise FilesChanged(null))
        if (_fileUpload is not null)
        {
            try { await _fileUpload.ClearAsync(); }
            catch { /* ignore */ }
        }

        StateHasChanged();
    }

    public async Task OnDetectionChanged(string selected)
    {
        _detectionMethodSelected.Add(selected);

        await ClearAsync();
        StateHasChanged();
    }
}
